```toc

```
#### 1. python迭代器，生成器？
- 共同点：
	- 都是惰性计算：每次调用生成一个值，不会一次性加载完所有数据 ==> 节省内存
	- 都可用于for循环
	- 都可以用next()获取值
	``` python
	a = [1, 2, 3]
	iter_num = iter(a)
	print(next(iter_nums))  # 输出1 
	print(next(iter_nums))  # 输出2
	print(next(iter_nums))  # 输出1
	print(next(iter_nums))  # 报错StopIteration
	```
- 迭代器 iteration
	- 定义方式：定义了\__iter\__()和\_\_next__()的类
	- **需要手动管理状态**，如状态变量current、什么时候停止、状态推进current+=1 ==> 代码复杂度高
	- 使用场景：需要自己控制迭代逻辑时
- 生成器 generator
	- 定义方式：使用`yield`的函数或生成器表达式
	- 不需要自己写\__next\__和保存current ==> 代码简单
	- 使用场景：快速实现惰性序列或处理大数据流；顺序遍历
#### 2. yield用法？
- 是定义`生成器`的关键字，类似`return`但不结束函数，而是暂停执行保存状态，下一次迭代时继续
- 用于惰性计算，不一次性加载所有数据，用于处理`数据量大`或`无限序列`的场景，`节省内存`
#### 3. is和\==的区别
- is是比较是否为同一个对象，i.e. 内存地址
- \==是比较值
- 注意⚠️：字符串、整数等小对象有“缓存机制”
``` python
x = 100
y = 100
print(x == y)  # ✅ True
print(x is y)  # ✅ True（因为小整数共用同一块内存）

x = 1000
y = 1000
print(x == y)  # ✅ True
print(x is y)  # ❌ False（大整数未缓存，是两个不同对象）
```

#### 4. \_\_init\_\_和\_\_new\_\_的区别？
- \_\_init\_\_
	- 在**对象创建后**调用，初始化对象，属性设置
- \_\_new\_\_
	- 在**对象创建前**调用，创建对象开辟内存
	- obj = MyClass()实际已经调用了\__new\__()，不需要自己在MyClass中重写def \__new\__()

> [!faq]- 什么时候需要自己重新def \__new\__()呢？
> - 创建不可变类型的子类，如int, str, tuple
> - 实现单例模式
> - 在A()中实际要返回B()对象
> - 对象池/缓存机制，复用已有对象
> - 控制元类
		
#### 5. python的垃圾回收机制？如何知道要回收？如何知道对象没有被引用？
- 垃圾回收机制：引用计数器 + 循环引用检测
- 引用计数器
	- 可以用`sys.getrefcount(a)`来获取a的引用计数结果（⚠️调用该方法本身会+1次引用）
	- 当**引用计数为 0**，Python 立即释放该对象所占内存
- 循环引用检测
	- 用于检测**两个对象相互引用但外部没人引用它们**的情况
``` python
import gc

gc.collect()  # 强制执行一次垃圾回收
print(gc.garbage)  # 查看无法回收的对象（通常是有 __del__ 的循环引用）	
```
- 分代垃圾回收机制
	- 会更频繁的检查、清理新建对象，i.e. 第0代对象
#### 6. python的多线程？GIL锁？怎么使用？
- GIL全局解释锁，一种**线程互斥机制**，保证同一时刻只有一个线程执行python字节码 ==> **多线程不能并行跑多个CPU核心**
- python实现真正的多核并行可以用：多进程（multiprocessing），numpy，pypy，c扩展
#### 7. python里边，列表和集合，多个元素，新的元素a判断在不在这两个里边，哪个更快一点，时间复杂度是？
- 集合(set)更快，集合本质是哈希表

| 操作   | set（hash table） | list | tuple |
| ---- | --------------- | ---- | ----- |
| 增    | O(1)            | O(1) | 不可变   |
| 删    | O(1)            | O(n) | 不可变   |
| 查    | O(1)            | O(n) | O(n)  |
| 遍历全部 | O(n)            | O(n) | O(n)  |
#### 8. python中的b=a和b=a.copy()是一样的吗
- 如果a是**不可变对象**，则没有.copy()方法，b=a会让b和a指向同一个内存地址，但修改b时会新建一个对象不影响a
- 如果a是**可变对象，b=a** ==> b和a指向同一个内存地址，修改任意一个都会影响另一个	
```python
	id(b) == id(a)
```
- 如果a是**可变对象，b=a.copy()** ==> b是a的副本，但仅复制最外层对象，内层嵌套对象仍共享引用
``` python
a = [1, [2, 3]]
b = a.copy() # b = [1, [2, 3]], id(b) != id(a)
a = a[1] # a = [2, 3], b = [1, [2, 3]]
a[0] = 0 # a = [0, 3], b = [1, [0, 3]], id(b[1]) = id(a)
```
#### 9. 装饰器
